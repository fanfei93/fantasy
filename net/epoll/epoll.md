[TOC]





什么是多路复用

多路即多个socket连接，一路即一个socket连接

复用即一个进程或线程处理上面所有的连接。

如果不复用有需要同时服务多个客户端，需要多线程或多进程，这个就不是复用了。



## 1 网卡接收数据

网卡收到网线传来的数据

硬件电路的传输

写入内存

我们只需知道：**网卡会把数据写入内存**

## 2 如何知道接收了数据

计算机执行程序时，会有优先级的需求。比如，当计算机接受到断电信号时（电容可以保存少许电量，供CPU运行很短的一小段时间），它应立即去保存数据，保存数据的程序具有较高的优先级。

一般而言，由硬件产生的信号需要CPU立马做出回应（不然数据可能就丢失），所以它的优先级很高。CPU理应中断掉正在执行的程序，去做出响应；当CPU完成对硬件的响应后，再重新执行用户程序。中断的过程和函数调用差不多，只不过函数调用是事先定好位置，而中断的位置由“信号“决定。

**当网卡把数据写入内存后，网卡向CPU发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。**

## 3 进程阻塞为什么不占用CPU资源

先看一段普通的recv接收代码：

```c
//创建socket
int s = socket(AF_INET, SOCK_STREAM, 0);   
//绑定
bind(s, ...)
//监听
listen(s, ...)
//接受客户端连接
int c = accept(s, ...)
//接收客户端数据
recv(c, ...);
//将数据打印出来
printf(...)
```

这是一段基础的网络编程代码，先新建socket对象，依次调用bind、listen、accept，最后调用recv接收数据。recv是个阻塞方法，当程序运行recv时，它会一直等待，知道接收到数据才往下执行。

那么阻塞的原理是什么？

###3.1 工作队列

操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得CPU使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到recv时，程序会从运行状态转为等待状态，接受到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。

### 3.2 等待队列

当进程A执行到创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象。这个socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程。

当程序执行到recv时，操作系统将进程A从工作队列移动到该socket的等待队列中（只是添加了对这个“等待中”进程的引用）。cpu调度时只会执行工作队列中的进程，所以进程A被阻塞，不会往下执行代码，也不会占用CPU资源。

### 3.3 唤醒进程

当socket接收到数据后，操作系统将该socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。也由于socket的接收缓冲区已经有了数据，recv可以返回接受到的数据。

## 4 内核接收网络数据全过程

进程在recv阻塞期间，计算机收到了对端传送的数据（步骤①）。数据经由网卡传送到内存（步骤②），然后网卡通过中断信号通知cpu有数据到达，cpu执行中断程序（步骤③）。此处的中断程序主要有两项功能，先将网络数据写入到对应socket的接收缓冲区里面（步骤④），再唤醒进程A（步骤⑤），重新将进程A放入工作队列中。

两个问题：

**操作系统如何知道网络数据对应于哪个socket**

**如何同时监听多个socket的数据**

第一个问题：因为一个socket对应着一个端口号，而网络数据包中包含了ip和端口的信息，内核可以通过端口号找到对应的socket。为了提高处理速度，操作系统会维护端口号到socket的索引结构，以快速读取。

## 5 如何监听多个socket的数据

### 5.1 select

```c
int s = socket(AF_INET, SOCK_STREAM, 0);  
bind(s, ...)
listen(s, ...)

int fds[] =  存放需要监听的socket

while(1){
    int n = select(..., fds, ...)
    for(int i=0; i < fds.count; i++){
        if(FD_ISSET(fds[i], ...)){
            //fds[i]的数据处理
        }
    }
}
```

select的实现思路是，如果程序同时监听sock1、sock2、sock3三个socket，那么在调用socket之后，操作系统把进程A分别加入这三个socket的等待队列中。当任何一个socket收到数据后，中断程序将唤起进程。

这种方式很简单，但是有如下缺点：

1. 每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket。
2. 进程被唤醒后，程序并不知道哪些socket收到数据，还需要遍历一次。

补充说明：本节只解释了select的一种情形。当程序调用select时，内核会先遍历一遍socket，如果有一个以上的socket接收缓冲区有数据，那么select直接返回，不会阻塞。这也是为什么select的返回值有可能大于1的原因之一。如果没有socket有数据，进程才有阻塞。

## 6 epoll的设计思想

epoll是在select出现N多年后才被发明的，是select和poll的增强版本。epoll通过一下一些措施来改进效率。

### 6.1 功能分离

select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。每次调用select都需要执行这两个操作，然而大多数应用场景中，需要监视的socket相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。

先看一段epoll用法的代码：

```c
int s = socket(AF_INET, SOCK_STREAM, 0);   
bind(s, ...)
listen(s, ...)

int epfd = epoll_create(...);
epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中

while(1){
    int n = epoll_wait(...)
    for(接收到数据的socket){
        //处理
    }
}
```

功能分离，使得epoll有了优化的可能

### 6.2 就绪列表

select低效的另一个原因在于程序不知道哪些socket接收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的socket，就能避免遍历。如下图所示，计算机共有三个socket，收到数据的sock2和sock3被rdlist（就绪列表）所引用。当进程被唤醒后，只要获取rdlist的内容，就能够知道哪些socket收到数据。

## 7 epoll的原理和流程

### 7.1 创建epoll对象

当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象（也就是程序中的epfd代表的对象）。eventpoll对象也是文件系统中的一员，和socket一样，它也会有等待队列。创建一个代表该epoll的eventpoll对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为eventpoll的成员。

### 7.2 维护监视列表

创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket。以添加socket为例，如果通过epoll_ctl添加sock1、sock2和sock3的监视，内核会将eventpoll添加到这三个socket的等待队列中。

当socket接收到数据后，中断程序会操作eventpoll对象，而不是直接操作进程。

### 7.3 接收数据

当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。

eventpoll对象相当于是socket和进程之间的中介，socket的数据接收并不直接影响进程，而是通过改变eventpoll的就绪列表来改变进程状态。

当程序执行到epoll_wait时，如果rdlist已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，阻塞进程。

### 7.4 阻塞和唤醒进程

假设计算机中正在运行进程A和进程B，在某时刻进程A运行到了epoll_wait语句。内核会将进程A放入eventpoll的等待队列中，阻塞进程中。

当socket接收到数据，中断程序一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，进程A再次进入运行状态。也因为rdlist的存在，进程A可以知道哪些socket发生了变化。

## 8 epoll的实现细节

eventpoll包含了lock、mtx、wq(等待队列)、rdlist(就绪队列)、rbr(socket索引结构)等成员。

![img](https://pic4.zhimg.com/80/v2-e63254878f67751dcc07a25b93f974bb_hd.jpg)

### 8.1 就绪列表的数据结构

就绪列表引用着就绪的socket，所以它应该能够快速的插入数据。

程序可能随时调用epoll_ctl添加监视socket，也可能随时删除。当删除时，若该socket已经存放在就绪列表中，它也应该被移除。

所以就绪列表应是一种能够快速插入和删除的数据结构。双向链表就是这样一种数据结构，epoll使用双向链表来实现就绪队列。

### 8.2 索引结构

既然epoll将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的socket。至少要方便的添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入、和删除时间复杂度都是O(logN)，效率较好。epoll使用了红黑树作为索引结构。



来源：

[罗培羽：如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （1）](https://zhuanlan.zhihu.com/p/63179839)

[罗培羽：如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （2）](https://zhuanlan.zhihu.com/p/64138532)

[罗培羽：如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （3）](https://zhuanlan.zhihu.com/p/64746509)