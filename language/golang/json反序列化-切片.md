```
package main

import (
 "encoding/json"
 "fmt"
)

type AutoGenerated struct {
 Age   int    `json:"age"`
 Name  string `json:"name"`
 Child []int  `json:"child"`
}

func main() {
 jsonStr1 := `{"age": 14,"name": "potter", "child":[1,2,3]}`
 a := AutoGenerated{}
 json.Unmarshal([]byte(jsonStr1), &a)
 aa := a.Child
 fmt.Println(aa)
 jsonStr2 := `{"age": 12,"name": "potter", "child":[3,4,5,7,8,9]}`
 json.Unmarshal([]byte(jsonStr2), &a)
 fmt.Println(aa)
}
```

输出是：[1,2,3] [3,4,5]
### 解释
    要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。
    因此第一次解析时，a.Child 是 [1 2 3]，aa 自然也是 [1 2 3]。第二次解析时，a.Child 的长度会被重置为 0，也就说里面的值会被重置（比如 a.Child = a.Child[:0]），然后将 3,4,5,7,8,9 一个个 append 到 a.Child 中。
    
    而 append 操作可能会涉及到底层数组的扩容：当原来的容量不足时，会进行扩容。怎么扩容的呢？目前的版本（Go1.15.x）按照如下规则扩容：（扩容规则依赖具体实现，不同版本可能不一样）
```
// Get element of array, growing if necessary.
if v.Kind() == reflect.Slice {
  // Grow slice if necessary
  if i >= v.Cap() {
    newcap := v.Cap() + v.Cap()/2
    if newcap < 4 {
      newcap = 4
    }
    newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)
    reflect.Copy(newv, v)
    v.Set(newv)
  }
  if i >= v.Len() {
    v.SetLen(i + 1)
  }
}
```
初始容量最小为 4；
之后按照容量的一半扩容，所以容量是 4、6、9、13、19...

因此，第一次解析，aa.Child 是：[1 2 3]，cap = 4。第二次解析，aa.Child 先被重置，之后将 3,4,5,7,8,9 一个个 append，最后 aa.Child 是：[3 4 5 6 7 8 9], cap = 9。